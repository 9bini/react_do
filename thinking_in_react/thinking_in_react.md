# 리액트로 사고하기

리액트는 JS로 규모가 크고 빠른 웹 애플리케이션을 만든 가장 좋은 방법이니다. 
리액트는 페이스북과 인스타그렘을 통해 확장성을 증명했습니다.

리액트의 가장 멋진 점 중 하나는 앱을 설계하는 방식입니다.
이문서를 통해 래액트로 상품들을 검색할 수 있는 데이터 테이블을 만드는 과정을 함계 생각해 봅시다

## 목업으로 시작하기

JSON API와 목업을 디자이너로부터 받았다고 가정해 봅시다. 목업은 다음과 같을 것입니다.

JSON API는 아래와 같은 데이터를 반환합니다.

```json
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

## 1 단계: UI를 컴포넌트 계층 구조로 나눈기

우리가 할 첫 번째 일은 모든 컴포넌트(와 하위 컴포넌트)의 주변에 박스를 그리고 그 각각에 이름을 붙이는 것입니다.
디자이너와 함계 일한다면,
이것들을 이미 정해두었을 수 있으니 한번 대화해보세요!
디자이너의 Photoshop 레이어 이름이 래익트 컴포넌트의 이름이 될 수 있습니다.
> 힌트를 얻는 거지 답을 얻는 것은 아닌 것을 기억

하지만 어떤 것이 컴포넌트가 되어야 할지 어떻게 알 수 있을 까요?
우리가 새로운 함수나 객체를 만들 때처럼 만드시면 됩니다.
한 가지 테크익은 **단일 책임원칙**입니다.
이는 하나의 컴포넌트는 한 가지 일을 하는게 이상적이라는 원칙입니다.
하나의 컴포넌트가 커지게 된다면 이는 보다 작은 하위 컴포넌트로 분리 되어야합니다.

주로 JSON데이터를 유저에게 보여주기 때문에, 데이터 모델이 적절하게 만들어졌다면,
UI(컴포넌트 구조)가 잘 연결될 것 입니다. 이는 UI와 데이터 모델이 같은 *인포메이션 아키텍처*를 가지는 경향이 있기 때문입니다.
각 컴포넌트가 데이터 모델의 하 조각을 나태내도록 분리해주세요
![컴포넌트 분리](https://ko.reactjs.org/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png)

다섯개의 컴포넌트로 이루어진앱을 한번 봅시다. 각각의 컴포넌트에 들어간데이터 이탤릭체로 표기했습니다.

1. FilterableProductTable(노란색): 예시 전체를 포괄함니다.
2. SearchBar(파란색): 모든 유저의 입력을 받습니다.
3. ProductTable(연두색): 유저의 입력을 기반으로 데이터 콜렉션을 필터링 해서 보여줍니다.
4. ProductCategoryRow(하늘색): 각 카테고리의 헤더르 보여줍니다.
5. ProductRow(빨강색): 각각의 제품에 해당하는 행을 보여줍니다.

`ProductTable`을 보면 “Name” 과 “Price” 레이블을 포함한 테이블 헤더만을 가진 컴포넌트는 없습니다.
이 같은 경우, 데이터를 위한 독립된 컴포넌트를 생성할지 생성하지 않을지 선택입니다.
이 예시에서는 `ProductTable`의 책임인 *3.데이터컬렉션*이 렌더링의 일부이기 때문에 `ProductTable`을 남겨두었습니다.
그러나 이 헤더가 복잡해지면(즉 정렬을 위한 기능을 추가하는 등)
`ProductTableHeader`컴포넌트를 만드는 것이 더 합리적일 것입니다.

이제 목업에서 컴포넌트를 확인하였으므로 이를 계층 구조로 나열해 봅시다.
모형의 다른 컴포넌트 내부에 나타나는 컴포넌트는 계층 구조의 자식으로 나타냅니다.

* FilterableProductTable
    * SearchBar
    * ProductTable
        * ProductCategoryRow
        * ProductRow

## 2단계: 리액트로 정적인 버전 만들기

이제 컴포넌트 계층구조가 만들어졌으니 앱을 실제로 구현해볼 시간입니다.
가장 쉬운 방법은 데이터 모델을 가지고 UI를 렌더링은 되지만 아무 동작도 없는 버전을 만들어 보는 것입니다.
이처럼 과정을 나누는 것이 좋은데 정적버전을 만드는 것은 생각은 적게 필요하지만 타이핑은 많이 필요로 하고,
상호작용을 만드는 거은 생각은 많이 해야 하지만 타이핑은 적게 필요로 하기 때문입니다.

데이터 모델을 렌더링하는 앱의 정적 버젖을 만들기 위해 다른 컴포넌트를 재사용하는 컴포넌트를 만들고 props를 이용해 데이터를 전달 해줍시다. props는 부모가 자식에게 데이터를 넘겨줄 때 사용할 수 있는 방법이빈다.
정적 버전을 만들기 위해 state를 사용하지 마세요.
state는 오직 상호작용을 위해, 즉 시간이 지남에 따라 데이터가 바뀌는 것에 사용합니다. 
우리는 앱의 정적 버전을 만들고 있기 때문에 지금은 필요하지 않습니다.

앱을 만들 때 하향식이나 상향식으로 만들 수 있습니다.
다시 말해 계층 구조의 상부에서 있는 컴포넌트(FilterableProductTable)부터 만들거나 하층부에 잇는 컴포넌트(ProductRow) 부터 만들 수 있습니다. 
간단한 예시에서 보통하향식으로 만드는 게 쉽지만 프로젝트가 커지면 
상향식으로 만들고 테이스틑 작성하면서 개발하기가 더 쉽습니다.

이 단계가 끝나면 데이터 렌더링을위해 만들어진 재사용 가능한 컴포너트들의 라이브러리를 가지게 됩니다.
현재는 앱의 정적 버전이기 때문에 컴포넌트는 render() 메서드만 가지고 있을 것입니다.
계층 구조의 최상단 컴포넌트는 prop으로 데이터 모델을 받습니다.
데이터 모델이 변경되면 `ReactDOM.render()`를 다시 호출해서 UI가 업데이트 됩니다.
UI가 어덯게 업데이트되고 어디서 변경해야하는지 알 수 있습니다.
리액트의 단방향 데이터 흐름은 모든 것을 모듈화 하고 빠르게 만들어 줍니다.

### props와 state 차이
props는 함수 매개변수 처럼 컴포넌트에 전달되는 반면
state는 함수 내에 선언된 변수처럼 컴포넌트 안에서 관리

## 3단계: UI state에 대한 최소한의 (하지만 완전한) 표현 찾아내기

UI를 상호작용하게 만들려면 기반 데이터 모델을 변경할 수 있는 방법이 있어야 합니다.
이를 리액트는 state를 통해 변경합니다.

애플리케이션을 올바르게 만들기 위해서는 애플리케이션에서 필요로 하는 변경 가능한 state릐 최소 집합을 생각해보아야 합니다.
여기서 핵심은 **중복 배제**원칙입니다.
애플리케이션이 필요로 하는 가장 최소한의 state를 찾고 이를 통해 나머지 모든 것들이 필요에 따라 그때그때 계산되도록 만드세요.
예를 들어 TODO 리스트를 만든다고 하면,
TODO 아이템을 저장하는 배열만 유지하고 TODO 아이템의 개수를 표현하는 state를 별도로 만들지 마세요.
TODO 갯수를 렌더링해야한다면 TODO 아이템 배열의 길이를 가져오면 됩니다.

예시 애플리케이션 내데이터들을 생각해봅시다.
애플리케이션은 다음과 같은 데이터를 가지고 있습니다.

* 제품은 원본 목록
* 유저가 입력한 검색어
* 체크박스의 값
* 필터링된 제품들의 목록

각각 살펴보고 어떤 게 state가 되어야 하는 지 살펴봅시다. 
이는 각 데이터에 대해 아래의 세 가지 질문을 통해 결정할 수 있습니다.

1. 부모로 부터 props를 통해 전달됩니까? 그러면 확실히 state가 아닙니다.
2. 시간이 지나도 변하지 않나요? 그러면 확실히 state가 아닙니다.
3. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가요? 그럼 state가 아닙니다.

제품의 원본 목록은 props를 통해 전달되므로 state가 아닙니다.
검색어와 체크박스는 state로 볼 수 잇는데 시간이 지남에 따라 변하기도 하면서 다른 것들로부터 계산 될 수 없기 때문입니다.
그리고 마지막으로 필터링된 목록은 state가 아닙니다.
제품의 원본 목록과 검색어, 체크박스의 값을 조합해서 계산해낼 수 있기 때문입니다.

결과적으로 애플리케이션은 다음과 같은 state를 가집니다.
* 유저가 입력한 검색어
* 체크박스의 값

## 4단계: State가 어디에 있어야 할 지 찾기

어던 컴포넌트가 state를 변경하거나 소우할지 찾아야 합니다.

기억하세요: 리액트는 항상 컴포넌트 계층구조를 따라 아래로 내려가는 단방향 데이터 흐름을 따릅니다.
어떤 컴포넌트가 어던 state를 가져야하는 지 바로 결정하기 어려울 수 있습니다.
많은 초보자가 이부분을 가장 어려워합니다.

애플리케이션이 가지는 각각의 state에 대해서

* state를 기반으로 랜더링하는 모든 컴포넌트를 찾으세요
* 공통 소유 컴포넌트를 찾으세요
  계층 구조내에서 특정 state가 있어야 하는 모든 컴포넌트들의 상위에 잇는 하나의 컴포넌트
* 공통 혹은 더상위에 잇는 컴포넌느가 stae를 가져야 합니다.
* state를 소유할 적절한 컴포넌트를 차지 못하였다면, 
  stae를 소유하는 컴포넌트 하나 만들어서 공통 오너 컴포넌트의 상위 계층에 추가하세요.

## 5단계: 역방향 데이터 흐름 추가하기

리액트는 전통적인 양방향 데이터 바인딩과 비교하면 더 많은 타이핑을 필요로 하지만 
데이터 흐름을 명시적으로 보이게 만들어서 프로그램이 어떻게 동작하는지 파악할 수 있게 도와줍니다.
